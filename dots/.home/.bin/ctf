#!/bin/zsh

# CTF Challenge Manager
# Usage: ctf <command>
# Commands: init, solved

# Load history into this shell process
HISTFILE="$HOME/.zsh_history"
fc -R "$HISTFILE"

# Get flag prefix based on current directory path
get_flag_prefix() {
    local path="$(pwd)"
    case "$path" in
        *picoctf*|*picoCTF*)
            echo "picoCTF"
            ;;
        *htb*|*hackthebox*)
            echo "HTB"
            ;;
        *ctflearn*)
            echo "flag"
            ;;
        *tryhackme*|*thm*)
            echo "THM"
            ;;
        *ctftime*)
            echo "FLAG"
            ;;
        *)
            # No match - return empty
            echo ""
            ;;
    esac
}

# Function to get current history count
get_history_count() {
    history | tail -1 | awk '{print $1}'
}

# Function to find the last "ctf init" command in history
find_last_init() {
    history 200 | grep -P "^\s+\d+\s+ctf\s+init" | tail -1 | awk '{print $1}'
}

# Function to extract commands from history
extract_commands() {
    local start_num="$1"
    local end_num="$2"

    # Get commands from start to end, excluding the "ctf solved" command at the end
    history | awk -v start="$start_num" -v end="$((end_num - 1))" '
        $1 >= start && $1 <= end {
            # Remove the history number and print the rest
            $1 = "";
            sub(/^ +/, "");
            if ($0 !~ /^ctf (init|solved)/) print $0
        }
    '
}

# Initialize a new challenge
init_challenge() {
    local current_count=$(get_history_count)

    echo "üöÄ CTF Challenge initialized"
    echo "üîó History anchor set at: $current_count"
    echo "Run 'ctf solved' when you complete the challenge!"
}

# Mark challenge as solved
solve_challenge() {
    local solvedTxt="$(pwd)/solved.txt" 
    
    # Fast path: if solved.txt exists, use it
    if [[ -f $solvedTxt ]]; then
        echo "üéâ Challenge solved!"
        flag=$(cat $solvedTxt)
        echo "üèÅ Flag: $flag"
        if command -v wl-copy &> /dev/null; then
            echo $flag | wl-copy
        else
            echo "‚ö†Ô∏è  wl-copy not found, flag not copied to clipboard"
        fi
        mark_as_solved "$(pwd)"
        return 0
    fi

    # Find the last "ctf init" command
    local start_count=$(find_last_init)
    
    if [[ -z "$start_count" ]]; then
        echo "‚ö†Ô∏è  No 'ctf init' found in history. Commands won't be saved to solved.sh"
    fi

    # Get current history count
    local end_count=$(get_history_count)

    echo "üéâ Challenge solved!"

    # Create solved.sh file in current directory
    local solved_file="./solved.sh"

    # Extract and save commands if we found init
    if [[ -n "$start_count" ]]; then
        extract_commands "$((start_count + 1))" "$end_count" > "$solved_file"
        chmod +x "$solved_file"
        echo "‚úÖ Commands saved to: $solved_file"
    fi

    # Get the last command (the one before "ctf solved")
    local last_cmd=$(history | awk -v num="$((end_count - 1))" '$1 == num {$1 = ""; sub(/^ +/, ""); print $0}')
    
    if [[ -n "$last_cmd" && "$last_cmd" != "ctf solved" ]]; then
        echo "üîÑ Last command: $last_cmd"
        local flag=$(eval $last_cmd 2>&1)
        
        # If flag is empty or looks like an error, try auto-grep
        if [[ -z "$flag" || "$flag" == *"command not found"* || "$flag" == *"error"* ]]; then
            local prefix=$(get_flag_prefix)
            if [[ -n "$prefix" ]]; then
                echo "üîç Auto-detecting flag with prefix: $prefix"
                flag=$(echo "$flag" | grep -io "${prefix}{.*}" | head -1)
            fi
        fi
        
        if [[ -n "$flag" ]]; then
            echo "üèÅ Flag: $flag"
            if command -v wl-copy &> /dev/null; then
                echo $flag | wl-copy
            else
                echo "‚ö†Ô∏è  wl-copy not found, flag not copied to clipboard"
            fi
            mark_as_solved "$(pwd)"
            echo "‚ú® Challenge completed!"
        else
            echo "‚ùå Could not extract flag. Use 'ctf flag <flag>' to set it manually."
            return 1
        fi
    else
        echo "‚ùå No valid command found in history."
        return 1
    fi
}

mark_as_solved() {
    local folder="$1"
    if [[ "$folder" == *"(SOLVED)"* ]]; then
        echo "‚ö†Ô∏è  Folder already marked as solved"
        return 0
    fi
    if mv "$folder" "$folder (SOLVED)" 2>/dev/null; then
        return 0
    else
        echo "‚ö†Ô∏è  Could not rename folder to mark as solved"
        return 1
    fi
}

grep_flag() {
    local prefix=$1
    if [[ -z "$prefix" ]]; then
        prefix=$(get_flag_prefix)
        if [[ -z "$prefix" ]]; then
            echo "‚ùå No prefix provided and could not auto-detect from path"
            echo "Usage: ctf grep <prefix>"
            return 1
        fi
        echo "üîç Auto-detected prefix: $prefix"
    fi
    grep -io "${prefix}{.*}"
}

set_flag() {
    local flag=$1
    if [[ -z "$flag" ]]; then
        echo "‚ùå Usage: ctf flag <flag>"
        return 1
    fi
    echo "üèÅ Flag: $flag"
    echo "$flag" > solved.txt
    if command -v wl-copy &> /dev/null; then
        echo "$flag" | wl-copy
    else
        echo "‚ö†Ô∏è  wl-copy not found, flag not copied to clipboard"
    fi
    mark_as_solved "$(pwd)"
}

# Main command handler
case "$1" in
    "init")
        init_challenge
        ;;
    "solved")
        solve_challenge
        ;;
    "grep")
	grep_flag $2
	;;
    "flag")
	set_flag $2
	;;
    *)
        echo "‚ùå Usage: ctf <command>"
        echo "Commands:"
        echo "  init              - Initialize a new CTF challenge (starts tracking commands)"
        echo "  solved            - Mark challenge as solved (extracts flag from last command)"
        echo "  grep [prefix]     - Search for flag with given prefix (auto-detects if omitted)"
        echo "  flag <flag>       - Manually set the flag"
        exit 1
        ;;
esac
